from enum import Enum
from typing import ContextManager, Iterator, List, Optional, Tuple, Union

StringOrBytes = Union[str, bytes]
Double3 = Tuple[float, float, float]
Double6 = Tuple[float, float, float, float, float, float]
EventSourceType = Union["Source", "Generator"]

class LoggingBackend(Enum):
    STDERR: int = ...

class LogLevel(Enum):
    DEBUG: int = ...
    ERROR: int = ...
    INFO: int = ...
    WARN: int = ...

class DistanceModel(Enum):
    NONE: int = ...
    LINEAR: int = ...
    EXPONENTIAL: int = ...
    INVERSE: int = ...

class NoiseType(Enum):
    FILTERED_BROWN: int = ...
    UNIFORM: int = ...
    VM: int = ...

class PannerStrategy(Enum):
    HRTF: int = ...
    STEREO: int = ...

# Initialization functions:

def initialized(
    log_level: LogLevel = ...,
    logging_backend: LoggingBackend = ...,
    libsndfile_path: StringOrBytes = ...,
) -> ContextManager[None]: ...
def initialize(
    log_level: LogLevel = ...,
    logging_backend: LoggingBackend = ...,
    libsndfile_path: StringOrBytes = ...,
) -> None: ...
def shutdown() -> None: ...

class BiquadConfig:
    @staticmethod
    def design_identity() -> "BiquadConfig": ...
    @staticmethod
    def design_lowpass(freequency: float, q: float = ...) -> "BiquadConfig": ...
    @staticmethod
    def design_highpass(frequency: float, q: float = ...) -> "BiquadConfig": ...
    @staticmethod
    def design_bandpass(frequency: float, bandwidth: float) -> "BiquadConfig": ...

class _BaseObject:
    def __init__(self, _handle: int) -> None: ...
    def dec_ref(self) -> None: ...
    def get_userdata(self) -> object: ...
    def set_userdata(self, data: object) -> None: ...
    def configure_delete_behavior(linger: bool = ..., linger_timout: float = ...): ...

class Pausable(_BaseObject):
    def pause(self) -> None: ...
    def play(self) -> None: ...

# Hard to type factory here.
def register_stream_protocol(protocol: str, factory: ...): ...

class StreamHandle(_BaseObject):
    @staticmethod
    def from_file(path: StringOrBytes) -> "StreamHandle": ...
    @staticmethod
    def from_stream_params(
        protocol: StringOrBytes, path: StringOrBytes, param: int
    ) -> "StreamHandle": ...
    # Can't type Cython memoryviews.
    @staticmethod
    def from_memory(data) -> "StreamHandle": ...

class Buffer(_BaseObject):
    @staticmethod
    def from_stream_params(
        protocol: StringOrBytes,
        path: StringOrBytes,
    ) -> "Buffer": ...
    @staticmethod
    def from_file(path: StringOrBytes) -> "Buffer": ...
    # Note that we can't exactly type Cython memoryviews.
    @staticmethod
    def from_encoded_data(data) -> "Buffer": ...
    # again, we can't type CYthon memoryviews.
    @staticmethod
    def from_float_array(sr: int, channels: int, data) -> "Buffer": ...
    @staticmethod
    def from_stream_handle(stream: StreamHandle) -> "Buffer": ...
    def get_channels(self) -> int: ...
    def get_length_in_samples(self) -> int: ...
    def get_length_in_seconds(self) -> float: ...

class Generator(Pausable):
    gain: float = ...
    pitch_bend: float = ...

class Source(Pausable):
    gain: float = ...
    filter: BiquadConfig = ...
    def add_generator(self, generator: Generator) -> None: ...
    def remove_generator(self, generator: Generator) -> None: ...

class GlobalEffect(_BaseObject):
    gain: float = ...
    filter_input: BiquadConfig = ...
    def reset(self) -> None: ...

class Context(Pausable):
    default_closeness_boost: float = ...
    default_closeness_boost_distance: float = ...
    default_distance_max: float = ...
    default_distance_model: DistanceModel = ...
    default_distance_ref: float = ...
    default_gain: float = ...
    default_orientation: Double6 = ...
    default_panner_strategy: PannerStrategy = ...
    default_position: Double3 = ...
    default_rolloff: float = ...
    def __init__(self, enable_events: bool = ...) -> None: ...
    def config_route(
        self,
        output: Source,
        input: GlobalEffect,
        gain: float = ...,
        fade_time: float = ...,
        filter: BiquadConfig = ...,
    ) -> None: ...
    def enable_events(self) -> None: ...
    def get_events(self, limit: int = ...) -> Iterator["Event"]: ...
    def remove_route(
        self, output: Source, input: GlobalEffect, fade_time: float = ...
    ) -> None: ...

class DirectSource(Source):
    def __init__(self, context: "Context") -> None: ...

class AngularPannedSource(Source):
    azimuth: float = ...
    elevation: float = ...
    panning_scalar: float = ...
    def __init__(
        self,
        context: "Context",
        panner_strategy: "PannerStrategy" = ...,
        azimuth: float = ...,
        elevation: float = ...,
    ) -> None: ...

class ScalarPannedSource(Source):
    panning_scalar: float = ...
    def __init__(
        self,
        context: "Context",
        panner_strategy: "PannerStrategy" = ...,
        panning_scalar: float = ...,
    ) -> None: ...

class Source3D(Source):
    closeness_boost: float = ...
    closeness_boost_distance: float = ...
    distance_max: float = ...
    distance_model: DistanceModel = ...
    distance_ref: float = ...
    orientation: Double6 = ...
    position: Double3 = ...
    rolloff: float = ...
    def __init__(
        self,
        context: "Context",
        panner_strategy: "PannerStrategy" = ...,
        position: Tuple[float, float, float] = ...,
    ) -> None: ...

class BufferGenerator(Generator):
    buffer: Optional[Buffer] = None
    looping: bool = ...
    playback_position: float = ...
    def __init__(self, context: Context) -> None: ...

class EchoTapConfig:
    delay: float
    gain_l: float
    gain_r: float
    def __init__(self, delay: float, gain_l: float, gain_r: float) -> None: ...

class Event:
    context: Context
    source: Optional[EventSourceType]
    # __init__ shouldn't be used by user code, but can't easily be made private to Cython.

class FinishedEvent(Event):
    pass

class LoopedEvent(Event):
    pass

class GlobalEcho(GlobalEffect):
    def __init__(self, context: Context) -> None: ...
    def set_taps(self, taps: List[EchoTapConfig]) -> None: ...

class GlobalFdnReverb(GlobalEffect):
    late_reflections_delay: float = ...
    late_reflections_diffusion: float = ...
    late_reflections_hf_reference: float = ...
    late_reflections_hf_rolloff: float = ...
    late_reflections_lf_reference: float = ...
    late_reflections_lf_rolloff: float = ...
    late_reflections_modulation_depth: float = ...
    late_reflections_modulation_frequency: float = ...
    mean_free_path: float = ...
    t60: float = ...
    def __init__(self, context: Context) -> None: ...

class NoiseGenerator(Generator):
    noise_type: NoiseType = ...
    def __init__(self, context: Context, channels: int = ...) -> None: ...

class StreamingGenerator(Generator):
    looping: bool = ...
    playback_position: float = ...

    # staticmethod
    def from_stream_params(
        self,
        context: Context,
        protocol: StringOrBytes,
        path: StringOrBytes,
        options: StringOrBytes = ...,
    ) -> None: ...
    def from_file(path: StringOrBytes) -> "Buffer": ...

class SynthizerError(Exception): ...
